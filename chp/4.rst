第四章：函数式编程
=============================

历史
^^^^^^^

编程风格
^^^^^^^^^


变量不变性
^^^^^^^^^^

   

递归
^^^^^^^^^^^

续延
^^^^^^^^^^^

程序变换
^^^^^^^^^^^^^^
CPS?
ANF?


高阶函数
^^^^^^^^^^



模式匹配
^^^^^^^^^^^^^^^^^^^^^


1.模式匹配实现多态

::
     -module(area).
     -export([area/1])
    
     %正方形
     area({square, Side}) ->
         Side*Side;

     %圆形
     area({circle, Radius}) ->
        3.14*Radius*Radius;

     %三角形
     area({triangle, A, B, C}) ->
         S = (A + B + C)/2,
         math:sqrt(S*(S-A)*(S-B)(S-C));

     %其他形状
     area(Other) ->
         {undifined, Other}.




    -

列表解析
^^^^^^^^^^^^^^^


1.数据查询
::
     >1 Likes=[{yao, erlang},{wang,java},{qi, php},{yang, c#},{chen,java}]
     %查询一：Yao喜欢什么？
     >2 [X||{P,X} <- Likes,  P=:=yao]
     %查询二：谁喜欢Java？
     >3 [P||{P, X} <- Likes, X=:=java]
     
可以将以上的查询和表达式构造成函数，函数接受输入参数，并将上面的表达式抽象后作为函数体，这样其功能就大大增强了。

2.定义树及其搜索函数



惰性求值
^^^^^^^^^^
参数传递机制
- 值调用
- 换名调用
- 按需调用，惰性计算






浅谈lambda演算
^^^^^^^^^^^^^^^^^^^

语法

<expression>::=<name>|<function>|<application>

//函数抽象：用来生成函数

<function>::=λ<name>.<expression>
例：λ x. x+3

//函数作用：使函数作用于参数
<application>::=(<expression> <expression>)
例:λ x. x + 3 4 => 7


公理

α置换公理：
 λ x y. x+y == λ a b. a+b

β规约公理：
(λ x x. x+y) a b => a+b


Currying





实现递归


不动点


Y combinator

Y = λ f.(λ x. f(x x)) (λ x. f(x x))


Y combinator的意义：
  给lambda演算添加了一条引理：函数可以递归



函数式语言的编译
^^^^^^^^^^^^^^^^^
